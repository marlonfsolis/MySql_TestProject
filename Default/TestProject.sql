-- Script was generated by Devart dbForge Studio 2022 for MySQL, Version 9.1.21.0
-- Product home page: http://www.devart.com/dbforge/mysql/studio
-- Script date 2/26/2023 2:08:18 PM
-- Target server version: 8.0.32
-- Please backup your target database before running this script 

CREATE DATABASE IF NOT EXISTS test_project COLLATE utf8mb4_0900_ai_ci;
USE test_project;

# .\PreDeployment.sql

/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
# .\Tables\error_log.sql
CREATE TABLE error_log (
  error_log_id INT NOT NULL AUTO_INCREMENT,
  level INT NOT NULL,
  message MEDIUMTEXT NOT NULL,
  detail LONGTEXT DEFAULT NULL,
  stack_trace LONGTEXT DEFAULT NULL,
  error_date DATETIME DEFAULT NULL,
  PRIMARY KEY (error_log_id)
)
ENGINE = INNODB,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_0900_ai_ci;

# .\Procedures\sp_error_log_create.sql
DELIMITER $$

CREATE PROCEDURE sp_error_log_create(
  IN level int,
  IN message mediumtext,
  IN detail longtext,
  IN stack_trace longtext,
  IN error_date datetime
)
BEGIN

  --
  -- Variables
  --
  DECLARE error_log_id int DEFAULT 0;



  --
  -- Default values
  --


  --
  -- Log the error
  --
  INSERT INTO error_log
    SET level = level,
        message = message,
        detail = detail,
        stack_trace = stack_trace,
        error_date = error_date;
  

  SELECT LAST_INSERT_ID()
    INTO error_log_id; 


  
  --
  -- Send error info back
  --
  SELECT error_log_id;

END
$$

DELIMITER ;

# .\Tables\error_log_trace.sql
CREATE TABLE error_log_trace (
  error_log_trace_id INT NOT NULL AUTO_INCREMENT,
  error_log_id INT NOT NULL,
  message LONGTEXT DEFAULT NULL,
  trace_date DATETIME NOT NULL,
  PRIMARY KEY (error_log_trace_id)
)
ENGINE = INNODB,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_0900_ai_ci;

ALTER TABLE error_log_trace 
  ADD CONSTRAINT FK_ErrorLogTrace_ErrorLog_ErrorLogId FOREIGN KEY (error_log_id)
    REFERENCES error_log(error_log_id) ON DELETE CASCADE ON UPDATE CASCADE;

# .\Procedures\sp_handle_error.sql
DELIMITER $$

CREATE PROCEDURE sp_handle_error(
  IN error_msg text,
  IN detail text,
  IN stack_trace text,
  IN procedure_name varchar(100),
  INOUT result json
)
BEGIN

  --
  -- Variables
  --
  DECLARE detail longtext DEFAULT NULL;
  DECLARE error_logid int DEFAULT 0;



  --
  -- Default values
  --
  SET error_msg = IFNULL(error_msg, 'N/A');
  SET procedure_name = IFNULL(procedure_name, 'N/A');
  
  IF JSON_VALID(result) = 0 THEN
    SET result = JSON_OBJECT('success', TRUE, 'msg', '', 'errorLogId', 0, 'recordCount', 0);
  END IF;



  --
  -- Get error info
  --
  SELECT CONCAT(procedure_name, ' - ', error_msg) 
    INTO error_msg;


  --
  -- Log the error
  --
	INSERT INTO error_log (message, detail, stack_trace, error_date)
		VALUES (error_msg, detail, stack_trace, NOW());

  SELECT LAST_INSERT_ID()
    INTO error_logid;



  INSERT INTO error_log_trace (error_logid, message, trace_date)
    SELECT 
      error_logid,
      lm.log_msg,
      lm.log_date
    FROM log_message lm;    


  

  --
  -- Send error info back
  --
  SET result = JSON_SET(result, 
      '$.success', FALSE, 
      '$.msg', error_msg, 
      '$.errorLogId', error_logid, 
      '$.recordCount', 0);

END
$$

DELIMITER ;

# .\Procedures\sp_error_log_truncate.sql
DELIMITER $$

CREATE PROCEDURE sp_error_log_truncate()
BEGIN
  
  --
  -- Truncate traces
  --
  TRUNCATE error_log_trace;


  --
  -- Drop foreign key
  --
  ALTER TABLE error_log_trace
    DROP CONSTRAINT FK_ErrorLogTrace_ErrorLog_ErrorLogid;


  --
  -- Truncate errors
  --
  TRUNCATE error_log;
  
  

  --
  -- Create foreign key
  --
  ALTER TABLE error_log_trace
  ADD CONSTRAINT FK_ErrorLogTrace_ErrorLog_ErrorLogid FOREIGN KEY (error_logid)
  REFERENCES error_log (error_logid) ON DELETE RESTRICT ON UPDATE RESTRICT;



END
$$

DELIMITER ;

# .\Procedures\sp_error_log_readlist.sql
DELIMITER $$

CREATE PROCEDURE sp_error_log_readlist(
  IN offset_rows int,
  IN fetch_rows int,
  IN filterJson json,
  IN searchJson json
)
BEGIN

  --
  -- Variables
  --

  -- filters
  DECLARE error_log_id_filter int;
  -- searchs
  DECLARE errormsg_search varchar(1000);


  --
  -- Temp tables
  --
  DROP TABLE IF EXISTS errors__sp_error_log_readlist;
  CREATE TEMPORARY TABLE errors__sp_error_log_readlist(
    error_logid int,
    message text
  );



  --
  -- Default values
  --
  SET offset_rows = IFNULL(offset_rows, 0);
  SET fetch_rows = IFNULL(fetch_rows, 10);
  
  IF fetch_rows = 0 THEN
    SELECT
      COUNT(1) INTO fetch_rows
    FROM error_log el;
  END IF;  
  IF JSON_VALID(filterJson) = 0 THEN
    SET filterJson = '{}';
  END IF;
  IF JSON_VALID(searchJson) = 0 THEN
    SET searchJson = '{}';
  END IF;



  --
  -- Get filter values
  --
  SELECT JSON_VALUE (filterJson, '$.errorLogId') INTO error_log_id_filter;


  --
  -- Get search values
  --
  SELECT JSON_VALUE (searchJson, '$.errorMsg') INTO errormsg_search;



  -- 
  -- Get errors result
  --
  INSERT INTO errors__sp_error_log_readlist (error_logid, message)
  SELECT
    el.error_logid,
    el.message
  FROM error_log el
  
  -- filter
  WHERE (error_log_id_filter IS NULL OR el.error_logid = error_log_id_filter)

  -- search
  AND (errormsg_search IS NULL OR errormsg_search LIKE el.message)
  
  ORDER BY el.error_date DESC
  LIMIT fetch_rows OFFSET offset_rows;



  --
  -- Get error log result
  --
  SELECT
    el.error_logid,
    el.message,
    el.detail,
    el.stack_trace,
    el.error_date
  FROM error_log el
  INNER JOIN errors__sp_error_log_readlist err
    ON el.error_log_id = err.error_logid;


  --
  -- Get error log trace result
  --
  SELECT
    elt.error_log_trace_id,
    elt.error_logid,
    elt.message,
    elt.trace_date
  FROM error_log_trace elt
  WHERE EXISTS (
    SELECT * FROM errors__sp_error_log_readlist errs WHERE errs.error_logid = elt.error_logid
  );


END
$$

DELIMITER ;

# .\Tables\role.sql
CREATE TABLE role (
  name VARCHAR(100) NOT NULL,
  description VARCHAR(1000) DEFAULT NULL,
  PRIMARY KEY (name)
)
ENGINE = INNODB,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_0900_ai_ci;

# .\Functions\fn_is_numeric.sql
DELIMITER $$

CREATE FUNCTION fn_is_numeric(
  input VARCHAR(255)
)
  RETURNS INT(11)
  DETERMINISTIC
RETURN input REGEXP '^[0-9]+\\.?[0-9]*$'
$$

DELIMITER ;

# .\Procedures\sp_handle_error_diagnostic.sql
DELIMITER $$

CREATE PROCEDURE sp_handle_error_diagnostic(
  IN sql_state text,
  IN errno int,
  IN error_msg text,
  IN log_msg json,
  IN procedure_name varchar(100),
  INOUT result json
)
BEGIN

  --
  -- Variables
  --
  DECLARE detail text DEFAULT NULL;
  DECLARE error_logid int DEFAULT 0;



  --
  -- Default values
  --
  SET sql_state = IFNULL(sql_state, 'N/A');
  SET errno = IFNULL(errno, 'N/A');
  SET error_msg = IFNULL(error_msg, 'N/A');
  SET procedure_name = IFNULL(procedure_name, 'N/A');
  
  IF JSON_VALID(result) = 0 THEN
    SET result = JSON_OBJECT('success', FALSE, 'msg', 'Error', 'errorLogId', 0, 'recordCount', 0);
  END IF;



  --
  -- Get error info
  --
  IF (SELECT fn_is_numeric(SUBSTR(error_msg,1,3))) = 0 THEN
    SET error_msg = CONCAT('500|',error_msg);
  END IF;

  SELECT 
    CONCAT('STORED PROC ERROR', 
      ' - PROC: ', procedure_name,
      ' - MYSQL_ERRNO: ', errno, 
      ' - RETURNED_SQLSTATE:', sql_state, 
      ' - MESSAGE_TEXT: ', error_msg)
    INTO detail;

  SELECT CONCAT(procedure_name, ' - ', error_msg) 
    INTO error_msg;


  --
  -- Log the error
  --
	INSERT INTO error_log (message, detail, stack_trace, error_date)
		VALUES (error_msg, detail, NULL, NOW());

  SELECT LAST_INSERT_ID()
    INTO error_logid;


  INSERT INTO error_log_trace (error_logid, message, trace_date)
  SELECT 
    error_logid AS 'error_logid',
    jt.msg AS 'message',
    IFNULL(jt.date,NOW()) AS 'trace_date'
  FROM JSON_TABLE(log_msg, '$[*]' COLUMNS(
    msg text PATH '$.msg',
    date datetime PATH '$.date'
  )) jt;  


  
  --
  -- Send error info back
  --
  SET result = JSON_SET(result, 
      '$.success', FALSE, 
      '$.msg', error_msg, 
      '$.errorLogId', error_logid, 
      '$.recordCount', 0);

END
$$

DELIMITER ;

# .\Tables\permission.sql
CREATE TABLE permission (
  name VARCHAR(100) NOT NULL,
  description VARCHAR(1000) DEFAULT NULL,
  PRIMARY KEY (name)
)
ENGINE = INNODB,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_0900_ai_ci;

# .\Scripts\Temp 3.sql
DELIMITER $$

CREATE PROCEDURE sp_tran_test3(
  OUT error_code int
)
BEGIN

  DECLARE procedure_name varchar(100) DEFAULT 'sp_tran_test3';
  DECLARE result json DEFAULT JSON_OBJECT('success', TRUE, 'msg', '', 'errorLogId', 0, 'recordCount', 0);
  DECLARE within_tran bool;
  DECLARE throwerror int DEFAULT 0;

  DECLARE EXIT HANDLER FOR SQLEXCEPTION 
  BEGIN
    GET DIAGNOSTICS @cno = NUMBER;
    GET CURRENT DIAGNOSTICS CONDITION @cno
      @sqlstate = RETURNED_SQLSTATE, 
      @errno = MYSQL_ERRNO,
      @text = MESSAGE_TEXT;
    SELECT @sqlstate, @errno, @text;    

    SET error_code = 10;

    IF within_tran THEN
      ROLLBACK; -- TO sp_tran_test3;
    ELSE
      ROLLBACK;
    END IF;

  END;


  --
  -- Check if transaction exist
  --
  CALL sp_is_in_transaction(within_tran);


  --
  -- Create transaction or savepoint
  --
  IF within_tran THEN
    SAVEPOINT sp_tran_test3;
    SELECT 'Save point added - sp_tran_test3';
  ELSE
    START TRANSACTION;
    SELECT 'Transacton started - sp_tran_test3';
  END IF;

  


  INSERT INTO permission
    SET name = 'Permission6',
        description = 'Permission 6';



--   INSERT INTO role
--     SET name = 'Group4',
--         description = 'Group 4';

    
    
--   SET throwerror = 1/0;

  
  IF NOT within_tran THEN
    COMMIT;
    SELECT 'Commited - sp_tran_test3';
  END IF;

  SET error_code = 0;


END
$$

DELIMITER ;

# .\Procedures\sp_tran_test1_2.sql
DELIMITER $$

CREATE PROCEDURE sp_tran_test1_2(
  IN auto_commit bool,
  OUT error_code int 
)
BEGIN

  DECLARE throwerror int DEFAULT 0;

  DECLARE EXIT HANDLER FOR SQLEXCEPTION 
  BEGIN
    GET CURRENT DIAGNOSTICS CONDITION 1
      @sqlstate = RETURNED_SQLSTATE, 
      @errno = MYSQL_ERRNO,
      @text = MESSAGE_TEXT;
    SELECT @sqlstate, @errno, @text;    


    SET error_code = 1;
    
--     IF auto_commit THEN
--       ROLLBACK;
--       SET AUTOCOMMIT = 1;
--     END IF;

  END;

  --
  -- Default values
  --
--   SET AUTOCOMMIT = 0;
  SET auto_commit = IFNULL(auto_commit,TRUE);


  --
  -- Do stuff
  --
  INSERT INTO permission
    SET name = 'Permission6',
        description = 'Permission 6';  

  -- Error
  SET throwerror = 1/0;

  -- Commit
--   IF auto_commit THEN
--     COMMIT;
--     SET AUTOCOMMIT = 1;
--   END IF;

  -- Send success
  SET error_code = 0;

END
$$

DELIMITER ;

# .\Scripts\Temp 2.sql
DELIMITER $$

CREATE PROCEDURE permissions_readlist()
BEGIN

 SELECT * FROM permission;

END
$$

DELIMITER ;

# .\Tables\permission_role.sql
CREATE TABLE permission_role (
  permission_name VARCHAR(100) NOT NULL DEFAULT '',
  role_name VARCHAR(100) NOT NULL DEFAULT '',
  PRIMARY KEY (permission_name, role_name)
)
ENGINE = INNODB,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_0900_ai_ci;

ALTER TABLE permission_role 
  ADD CONSTRAINT FK_PermissionRole_Permission_Name FOREIGN KEY (permission_name)
    REFERENCES permission(name);

ALTER TABLE permission_role 
  ADD CONSTRAINT FK_PermissionRole_Group_Name FOREIGN KEY (role_name)
    REFERENCES role(name);

# .\Tables\users.sql
CREATE TABLE users (
  user_id INT NOT NULL AUTO_INCREMENT,
  first_name VARCHAR(200) NOT NULL,
  last_nName VARCHAR(200) NOT NULL,
  email VARCHAR(500) NOT NULL,
  user_password VARCHAR(1000) DEFAULT NULL,
  PRIMARY KEY (user_id)
)
ENGINE = INNODB,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_0900_ai_ci;

# .\Scripts\Temp 4.sql
DELIMITER $$

CREATE PROCEDURE sp_temptable_test_2()
BEGIN

  DECLARE throwerror int DEFAULT 0;


  DROP TABLE IF EXISTS temp_table CASCADE;
  CREATE TEMPORARY TABLE temp_table(
    message text,
    date datetime
  );
  
  INSERT INTO temp_table (message, date) VALUES ('Message 1 on 2', NOW());
      
--  SET throwerror = 1/0;

  INSERT INTO temp_table (message, date) VALUES ('Message 2 on 2', NOW());


END
$$

DELIMITER ;

# .\Scripts\Temp 4.sql
DELIMITER $$

CREATE PROCEDURE sp_temptable_test_1()
BEGIN

  DECLARE throwerror int DEFAULT 0;


  DROP TABLE IF EXISTS temp_table CASCADE;
  CREATE TEMPORARY TABLE temp_table(
    message text,
    date datetime
  );
  
  INSERT INTO temp_table (message, date) VALUES ('Message 1 on 1', NOW());


  CALL sp_temptable_test_2();
    

  INSERT INTO temp_table (message, date) VALUES ('Message 2 on 1', NOW());
    
--  SET throwerror = 1/0;

  SELECT * FROM temp_table;

END
$$

DELIMITER ;

# .\Procedures\sp_within_transaction.sql
DELIMITER $$

CREATE PROCEDURE sp_within_transaction(OUT within_transaction bool)
BEGIN

  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION # 1305
  BEGIN
    SET within_transaction = FALSE; # on error realize we are NOT in a transaction
  END;

  SET within_transaction = TRUE;
  SAVEPOINT savepoint_sp_within_transaction;
  ROLLBACK TO SAVEPOINT savepoint_sp_within_transaction;



END
$$

DELIMITER ;

# .\Scripts\sp_tran_test1.sql
DELIMITER $$

CREATE PROCEDURE sp_tran_test1(
  OUT error_code int 
)
BEGIN

  DECLARE throwerror int DEFAULT 0;
  DECLARE within_tran bool DEFAULT FALSE;
  DECLARE procedure_name text DEFAULT 'sp_tran_test1';

  DECLARE EXIT HANDLER FOR SQLEXCEPTION 
  BEGIN
    GET DIAGNOSTICS @cno = NUMBER;
    GET CURRENT DIAGNOSTICS CONDITION @cno
      @sqlstate = RETURNED_SQLSTATE, 
      @errno = MYSQL_ERRNO,
      @text = MESSAGE_TEXT;
    SELECT @sqlstate, @errno, @text;    


    SET error_code = 1;
   
    IF within_tran THEN
      ROLLBACK TO SAVEPOINT sp_tran_test1;
    ELSE
       ROLLBACK; 
    END IF;

  END;

  --
  -- default values
  --
  CALL sp_within_transaction(within_tran);
  SELECT within_tran;
  

  --
  -- Start Tran or Savepoint
  --
  IF within_tran THEN
    SAVEPOINT sp_tran_test1;
    SELECT 'SAVEPOINT sp_tran_test1';
  ELSE 
    START TRANSACTION;
    SELECT 'START TRANSACTION';
  END IF;
  


  --
  -- Call to proc
  --
  CALL sp_tran_test1_2(FALSE, error_code);

  -- Here we do not rolled bac yet. We should have values
--   CALL sp_permissions_readlist(0, 0, NULL, NULL, @result);
  

  -- Handle error
  IF error_code > 0 THEN
    SELECT 'ERROR: sp_tran_test1_2';
    
    SIGNAL SQLSTATE '12345' 
      SET MESSAGE_TEXT = 'ERROR: sp_tran_test1_2';    

  END IF;

  -- Error
--   SET throwerror = 1/0;

  -- Commit
  IF within_tran THEN
    COMMIT;
  END IF;

  -- Send success
  SET error_code = 0;

END
$$

DELIMITER ;

# .\Functions\fn_add_log_message.sql
DELIMITER $$

CREATE FUNCTION fn_add_log_message(
  log_array json,
  msg text
)
  RETURNS JSON
  DETERMINISTIC
BEGIN
  IF JSON_VALID(log_array) = 0 THEN
    SET log_array = JSON_ARRAY();
  END IF;

  SELECT
    JSON_MERGE_PRESERVE(
      log_array, 
      JSON_OBJECT('msg', msg, 'date', NOW())
    ) 
    INTO log_array;

  RETURN log_array;
END
$$

DELIMITER ;

# .\Procedures\sp_user_write.sql
DELIMITER $$

CREATE PROCEDURE sp_users_write(
  IN p_json json,
  OUT result json
)
BEGIN

  --
  -- Variables
  --
  DECLARE procedure_name varchar(100) DEFAULT 'sp_users_write';
  DECLARE error_msg varchar(1000) DEFAULT '';
  DECLARE error_log_id int DEFAULT 0;
  DECLARE v_count int DEFAULT 0;
  DECLARE log_msgs json DEFAULT JSON_ARRAY();
  DECLARE within_tran bool DEFAULT FALSE;
  DECLARE tran_started bool	DEFAULT	TRUE;  

  -- Fields
  DECLARE user_id int;
  


  --
  -- Error handling declarations
  --
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    -- Get error info
    GET CURRENT DIAGNOSTICS CONDITION 1
      @sqlstate = RETURNED_SQLSTATE, 
      @errno = MYSQL_ERRNO,
      @text = MESSAGE_TEXT;

	IF tran_started	THEN
		ROLLBACK;
	ELSE
		 ROLLBACK TO SAVEPOINT sp_users_write;	
	END	IF;

	CALL sp_handle_error_diagnostic(@sqlstate, @errno, @text,	log_msgs,	procedure_name,	result);

  END;


  --
  -- Temp tables
  --
  DROP TEMPORARY TABLE IF EXISTS response___sp_users_write;
  CREATE TEMPORARY TABLE response___sp_users_write 
    SELECT * FROM users u LIMIT 0;



  --
  -- Log the parameter values passed
  --
  SELECT fn_add_log_message(log_msgs, 'ParameterList:') INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('p_json: ', IFNULL(p_json, 'NULL'))) INTO log_msgs;
	


  --
  -- Default values
  --
  CALL sp_within_transaction(within_tran);
  SET result = JSON_OBJECT('success', TRUE, 'msg', '', 'errorLogId', 0, 'recordCount', 0);
   


  --
  -- Start Tran	or Savepoint
  --
  IF within_tran THEN
	SAVEPOINT sp_users_write;
  ELSE 
	START TRANSACTION;
	SET	tran_started = TRUE;
  END IF;



  --
  -- Validate json input
  --
  IF JSON_VALID(p_json) = 0 THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = 'The json input is not valid.'; 
  END IF;


  --
  -- Get json values
  --
  SELECT
    JSON_VALUE (p_json, '$.user_id')
  INTO user_id;
  
  SELECT fn_add_log_message(log_msgs, 'Get json values done') INTO log_msgs;



  --
  -- Validate json values
  --
  IF IFNULL(user_id,0)=0 THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = 'The field user_id is required.'; 

  END IF;
  
  IF EXISTS (
    SELECT 1 
    FROM users u 
    WHERE u.user_id = user_id
  ) 
  THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = 'The users u user_id already exist.';
     
  END IF;  
  

  SELECT fn_add_log_message(log_msgs, 'Validate json values done') INTO log_msgs;


  -- 
  -- Create users u
  --
  INSERT INTO users
    SET user_id = user_id;

  -- 
  -- Get final result
  --
  INSERT INTO response___sp_users_write (user_id, description)
  SELECT
    user_id
  FROM users u
  WHERE u.user_id = user_id;

 
  SELECT fn_add_log_message(log_msgs, 'Get final result done') INTO log_msgs;


  
  SELECT COUNT(*) FROM response___sp_users_write r INTO v_count;
  SELECT JSON_SET(result, '$.recordCount', v_count) INTO result;


  --  
  -- Send the response
  --
  SELECT
    r.*
  FROM response___sp_users_write r;
  


  -- Commit
  IF tran_started THEN
    COMMIT;
  END IF;

END
$$

DELIMITER ;

# .\Procedures\sp_permissions_update.sql
DELIMITER $$

CREATE PROCEDURE sp_permissions_update(
  IN p_name varchar(100),
  IN p_json json,
  OUT result json
)
BEGIN

  --
  -- Variables
  --
  DECLARE procedure_name varchar(100) DEFAULT 'sp_permissions_update';
  DECLARE error_msg varchar(1000) DEFAULT '';
  DECLARE error_log_id int DEFAULT 0;
  DECLARE v_count int DEFAULT 0;
  DECLARE log_msgs json DEFAULT JSON_ARRAY();
	DECLARE	within_tran	bool DEFAULT FALSE;
	DECLARE	tran_started bool	DEFAULT	TRUE;

  -- Fields
  DECLARE name varchar(100);
  DECLARE description varchar(1000);
  


  --
  -- Error handling declarations
  --
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    -- Get error info
    GET CURRENT DIAGNOSTICS CONDITION 1
      @sqlstate = RETURNED_SQLSTATE, 
      @errno = MYSQL_ERRNO,
      @text = MESSAGE_TEXT;

		IF tran_started	THEN
			ROLLBACK;
		ELSE
			 ROLLBACK	TO SAVEPOINT sp_permissions_update;	
		END	IF;

		CALL sp_handle_error_diagnostic(@sqlstate, @errno, @text,	log_msgs,	procedure_name,	result);

  END;
   
  --
  -- Temp tables
  --
  DROP TEMPORARY TABLE IF EXISTS response___sp_permissions_update;
  CREATE TEMPORARY TABLE response___sp_permissions_update 
    SELECT * FROM permission p LIMIT 0;



  --
  -- Log the parameter values passed
  --
  SELECT fn_add_log_message(log_msgs, 'ParameterList:') INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('p_name: ', IFNULL(p_name, 'NULL'))) INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('p_json: ', IFNULL(p_json, 'NULL'))) INTO log_msgs;




  --
  -- Default values
  --
  CALL sp_within_transaction(within_tran);
  SET result = JSON_OBJECT('success', TRUE, 'msg', '', 'errorLogId', 0, 'recordCount', 0);
   


	--
	-- Start Tran	or Savepoint
	--
	IF within_tran THEN
		SAVEPOINT	sp_permissions_update;
	ELSE 
		START	TRANSACTION;
		SET	tran_started = TRUE;
	END	IF;


  --
  -- Validate input
  --
  IF IFNULL(p_name,'') = '' THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = '400|The old permission name is required.';
     
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM permission p WHERE p.name = p_name
  ) THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = '404|The permission to be updated was not found.';
     
  END IF;
  IF JSON_VALID(p_json) = 0 THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = '400|The json input is not valid.';
     
  END IF;



  --
  -- Get json values
  --
  SELECT
    JSON_VALUE (p_json, '$.name'),
    JSON_VALUE (p_json, '$.description') 
  INTO name, 
      description;
  
  SELECT fn_add_log_message(log_msgs, 'Get json values done') INTO log_msgs;



  --
  -- Validate json values
  --
  IF IFNULL(name,'')='' THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = '400|The new field name is required.';
     
  END IF;

  IF EXISTS (
    SELECT 1 
    FROM permission p 
    WHERE p.name = name
    AND p.name != p_name
  ) 
  THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = '400|The permission name already exist.';
     
  END IF;
  
  SELECT fn_add_log_message(log_msgs, 'Validate json values done') INTO log_msgs;



  -- 
  -- Update permission
  -- 
  UPDATE permission p
    SET p.name = name,
        p.description = description
  WHERE p.name = p_name;



  -- 
  -- Get final result
  --
  INSERT INTO response___sp_permissions_update (name, description)
  SELECT
    name,
    description
  FROM permission p
  WHERE p.name = name;

  SELECT fn_add_log_message(log_msgs, 'Get final result done') INTO log_msgs;


  
  SELECT COUNT(*) FROM response___sp_permissions_update r INTO v_count;
  SELECT JSON_SET(result, '$.recordCount', v_count) INTO result;



  --  
  -- Send the response
  --
  SELECT
    r.name,
    r.description
  FROM response___sp_permissions_update r;



	-- Commit
	IF tran_started	THEN
		COMMIT;
	END	IF;	
 
END
$$

DELIMITER ;

# .\Procedures\sp_permissions_readlist.sql
DELIMITER $$

CREATE PROCEDURE sp_permissions_readlist(
  IN offsetRows int,
  IN fetchRows int,
  IN filterJson json,
  IN searchJson json,
  OUT result json
)
BEGIN

  --
  -- Variables
  --
  DECLARE procedure_name varchar(100) DEFAULT 'sp_permissions_readlist';
  DECLARE error_msg text DEFAULT '';
  DECLARE error_log_id int DEFAULT 0;
  DECLARE v_count int DEFAULT 0;
  DECLARE log_msgs json DEFAULT JSON_ARRAY();

  -- filters
  DECLARE name_filter varchar(100);
  DECLARE description_filter varchar(1000);
  -- searchs
  DECLARE name_search varchar(100);
  DECLARE description_search varchar(1000);


  --
  -- Error handling declarations
  --
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    -- Get error info
    GET CURRENT DIAGNOSTICS CONDITION 1
      @sqlstate = RETURNED_SQLSTATE, 
      @errno = MYSQL_ERRNO,
      @text = MESSAGE_TEXT;

    CALL sp_handle_error_diagnostic(@sqlstate, @errno, @text, log_msgs, procedure_name, result);

  END;

  --
  -- Temp tables
  --
  DROP TEMPORARY TABLE IF EXISTS response___sp_permissions_readlist;
  CREATE TEMPORARY TABLE response___sp_permissions_readlist 
    SELECT * FROM permission p LIMIT 0;



  --
  -- Log the parameter values passed
  --
  SELECT fn_add_log_message(log_msgs, 'ParameterList:') INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('offsetRows: ', IFNULL(CAST(offsetRows AS CHAR), 'NULL'))) INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('fetchRows: ', IFNULL(CAST(fetchRows AS char(20)), 'NULL'))) INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('filterJson: ', IFNULL(filterJson, 'NULL'))) INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('searchJson: ', IFNULL(CAST(searchJson AS char), 'NULL'))) INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('ProfileId: ', IFNULL(CAST(0 AS char), 'NULL'))) INTO log_msgs;



  --
  -- Default values
  --
  SET offsetRows = IFNULL(offsetRows, 0);
  SET fetchRows = IFNULL(fetchRows, 10);
  SET result = JSON_OBJECT('success', TRUE, 'msg', '', 'errorLogId', 0, 'recordCount', 0);
  
  IF fetchRows = 0 THEN
    SELECT
      COUNT(1) INTO fetchRows
    FROM permission p;
  END IF;  
  IF JSON_VALID(filterJson) = 0 THEN
    SET filterJson = '{}';
  END IF;
  IF JSON_VALID(searchJson) = 0 THEN
    SET searchJson = '{}';
  END IF;

  SELECT fn_add_log_message(log_msgs, 'Default values done') INTO log_msgs;



  --
  -- Get filter values
  --
  SELECT
    JSON_VALUE (filterJson, '$.name'),
    JSON_VALUE (filterJson, '$.description') 
  INTO name_filter,
      description_filter;
  
  SELECT fn_add_log_message(log_msgs, 'Get filter values done') INTO log_msgs;



  --
  -- Get search values
  --
  SELECT
    JSON_VALUE (searchJson, '$.name'),
    JSON_VALUE (searchJson, '$.description') 
  INTO name_filter,
      description_filter;

  SELECT fn_add_log_message(log_msgs, 'Get search values done') INTO log_msgs;



  -- 
  -- Get final result
  --
  INSERT INTO response___sp_permissions_readlist (name, description)
  SELECT
    p.name,
    p.description
  FROM permission p
  
  -- filter
  WHERE (name_filter IS NULL OR name_filter = p.name)
  AND (description_filter IS NULL OR description_filter = p.description)

  -- search
  AND (name_search IS NULL OR p.name LIKE name_search)
  AND (description_search IS NULL OR p.description LIKE description_search);
  
  SELECT fn_add_log_message(log_msgs, 'Get final result done') INTO log_msgs;

  
  SELECT COUNT(*) FROM response___sp_permissions_readlist r INTO v_count;
  SELECT JSON_SET(result, '$.recordCount', v_count) INTO result;

  SELECT fn_add_log_message(log_msgs, 'Result count done') INTO log_msgs;


  --  
  -- Send the response
  --
  SELECT
    r.name,
    r.description
  FROM response___sp_permissions_readlist r;


END
$$

DELIMITER ;

# .\Scripts\Temp 3.sql
DELIMITER $$

CREATE PROCEDURE sp_tran_test2()
BEGIN

  DECLARE procedure_name varchar(100) DEFAULT 'sp_tran_test2';
  DECLARE error_code int DEFAULT 0;
  DECLARE within_tran bool;
  DECLARE throwerror int DEFAULT 0;

  DECLARE EXIT HANDLER FOR SQLEXCEPTION 
  BEGIN
    GET DIAGNOSTICS @cno = NUMBER;
    GET CURRENT DIAGNOSTICS CONDITION @cno
      @sqlstate = RETURNED_SQLSTATE, 
      @errno = MYSQL_ERRNO,
      @text = MESSAGE_TEXT;
    SELECT @sqlstate, @errno, @text;    

    
    IF within_tran THEN
      ROLLBACK; -- TO sp_tran_test2;
    ELSE
      ROLLBACK;
    END IF;

  END;


  --
  -- Check if transaction exist
  --
  CALL sp_is_in_transaction(within_tran);


  --
  -- Create transaction or savepoint
  --
  IF within_tran THEN
    SAVEPOINT sp_tran_test2;
    SELECT 'Save point added - sp_tran_test2';
  ELSE
    START TRANSACTION;
    SELECT 'Transacton started - sp_tran_test2';
  END IF;


  CALL sp_tran_test3(error_code);
        
--   SET throwerror = 1/0;

  CALL sp_permissions_readlist(0,0,NULL,NULL,@result);


  IF NOT within_tran THEN
    COMMIT;
    SELECT 'Commited - sp_tran_test3';
  END IF;

END
$$

DELIMITER ;

# .\Scripts\Temp 2.sql
DELIMITER $$

CREATE PROCEDURE run_test()
BEGIN

  DECLARE error_code int DEFAULT 0;

  START TRANSACTION;

  CALL sp_tran_test1(error_code);

  -- because we use SAVEPOINT. At this point we have BEEN ROLLED BACK already inside the proc
  -- This have the advantage that we can rollback only the proc with error and continue doint stuff
  CALL sp_permissions_readlist(0, 0, NULL, NULL, @result); -- use TEMPORARY key word to drop temp tables

  IF error_code > 0 THEN
    SELECT 'Rolloing back';
    ROLLBACK;
  ELSE
    SELECT 'Committing';
    COMMIT;
  END IF;

  CALL sp_permissions_readlist(0, 0, NULL, NULL, @result);

END
$$

DELIMITER ;

# .\Procedures\sp_permissions_read.sql
DELIMITER $$

CREATE PROCEDURE sp_permissions_read(
  IN permission_name varchar(100),
  OUT result json
)
BEGIN

  --
  -- Variables
  --
  DECLARE procedure_name varchar(100) DEFAULT 'sp_permissions_read';
  DECLARE error_msg varchar(1000) DEFAULT '';
  DECLARE error_log_id int DEFAULT 0;
  DECLARE v_count int DEFAULT 0;
  DECLARE log_msgs json DEFAULT JSON_ARRAY();


  --
  -- Error handling declarations
  --
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    -- Get error info
    GET CURRENT DIAGNOSTICS CONDITION 1
      @sqlstate = RETURNED_SQLSTATE, 
      @errno = MYSQL_ERRNO,
      @text = MESSAGE_TEXT;

    CALL sp_handle_error_diagnostic(@sqlstate, @errno, @text, log_msgs, procedure_name, result);

  END;


  --
  -- Temp tables
  --
  DROP TEMPORARY TABLE IF EXISTS response___sp_permissions_read;
  CREATE TEMPORARY TABLE response___sp_permissions_read 
    SELECT * FROM permission p LIMIT 0;



  --
  -- Log the parameter values passed
  --

  SELECT fn_add_log_message(log_msgs, 'ParameterList:') INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('permission_name: ', IFNULL(CAST(permission_name AS CHAR), 'NULL'))) INTO log_msgs;



  --
  -- Default values
  --
  SET result = JSON_OBJECT('success', TRUE, 'msg', '', 'errorLogId', 0, 'recordCount', 0);



  --
  -- Validate input value
  --
  IF IFNULL(permission_name,'')='' THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = '400|The field permission_name is required.';

  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM permission p WHERE p.name = permission_name
  ) THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = '404|The permission was not found.';
     
  END IF;
  
  SELECT fn_add_log_message(log_msgs, 'Validate input values done') INTO log_msgs;



  -- 
  -- Get final result
  --
  INSERT INTO response___sp_permissions_read (name, description)
  SELECT
    p.name,
    p.description
  FROM permission p
  WHERE p.name = permission_name;


  SELECT fn_add_log_message(log_msgs, 'Get final result done') INTO log_msgs;

  
  SELECT COUNT(*) FROM response___sp_permissions_read r INTO v_count;
  SELECT JSON_SET(result, '$.recordCount', v_count) INTO result;


  SELECT fn_add_log_message(log_msgs, 'Record count done') INTO log_msgs;



  --  
  -- Send the response
  --
  SELECT
    r.name,
    r.description
  FROM response___sp_permissions_read r;


END
$$

DELIMITER ;

# .\Procedures\sp_permissions_group_readlist.sql
DELIMITER $$

CREATE PROCEDURE sp_permissions_group_readlist(
  IN offsetRows int,
  IN fetchRows int,
  IN filterJson json,
  IN searchJson json,
  OUT result json
)
BEGIN

  --
  -- Variables
  --
  DECLARE procedure_name varchar(100) DEFAULT 'sp_permissions_group_readlist';
  DECLARE error_msg varchar(1000) DEFAULT '';
  DECLARE error_log_id int DEFAULT 0;
  DECLARE v_count int DEFAULT 0;
  DECLARE log_msgs json DEFAULT JSON_ARRAY();

  -- filters
  DECLARE group_name_filter varchar(100);
  DECLARE permission_name_filter varchar(100);
  -- searchs
  DECLARE group_name_search varchar(100);
  DECLARE permission_name_search varchar(100);


  --
  -- Error handling declarations
  --
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    -- Get error info
    GET CURRENT DIAGNOSTICS CONDITION 1
      @sqlstate = RETURNED_SQLSTATE, 
      @errno = MYSQL_ERRNO,
      @text = MESSAGE_TEXT;

    CALL sp_handle_error_diagnostic(@sqlstate, @errno, @text, log_msgs, procedure_name, result);

  END;


  --
  -- Temp tables
  --
  DROP TEMPORARY TABLE IF EXISTS response___sp_permissions_group_readlist;
  CREATE TEMPORARY TABLE response___sp_permissions_group_readlist 
    SELECT * FROM permission_role pg LIMIT 0;



  --
  -- Log the parameter values passed
  --
  SELECT fn_add_log_message(log_msgs, 'ParameterList:') INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('offsetRows: ', IFNULL(CAST(offsetRows AS CHAR), 'NULL'))) INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('fetchRows: ', IFNULL(CAST(fetchRows AS char(20)), 'NULL'))) INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('filterJson: ', IFNULL(filterJson, 'NULL'))) INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('searchJson: ', IFNULL(CAST(searchJson AS char), 'NULL'))) INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('ProfileId: ', IFNULL(CAST(0 AS char), 'NULL'))) INTO log_msgs;	


  --
  -- Default values
  --
  SET offsetRows = IFNULL(offsetRows, 0);
  SET fetchRows = IFNULL(fetchRows, 10);
  SET result = JSON_OBJECT('success', TRUE, 'msg', '', 'errorLogId', 0, 'recordCount', 0);
  
  IF fetchRows = 0 THEN
    SELECT
      COUNT(1) INTO fetchRows
    FROM permission_role pg;
  END IF;  
  IF JSON_VALID(filterJson) = 0 THEN
    SET filterJson = '{}';
  END IF;
  IF JSON_VALID(searchJson) = 0 THEN
    SET searchJson = '{}';
  END IF;



  --
  -- Get filter values
  --
  SELECT JSON_VALUE (filterJson, '$.group_name') INTO group_name_filter;
  SELECT JSON_VALUE (filterJson, '$.permission_name') INTO permission_name_filter;
  
  SELECT fn_add_log_message(log_msgs, 'Get filter values done') INTO log_msgs;


  --
  -- Get search values
  --
  SELECT JSON_VALUE (searchJson, '$.group_name') INTO group_name_search;
  SELECT JSON_VALUE (searchJson, '$.permission_name') INTO permission_name_search;
  
  SELECT fn_add_log_message(log_msgs, 'Get search values done') INTO log_msgs;



  -- 
  -- Get final result
  --
  INSERT INTO response___sp_permissions_group_readlist (group_name, permission_name)
  SELECT
    pg.group_name,
    pg.permission_name
  FROM permission_role pg
  
  -- filter
  WHERE (group_name_filter IS NULL OR group_name_filter = pg.group_name)
  AND (permission_name_filter IS NULL OR permission_name_filter = pg.permission_name)

  -- search
  AND (group_name_search IS NULL OR pg.group_name LIKE group_name_search)
  AND (permission_name_search IS NULL OR pg.permission_name LIKE permission_name_search);
 
  SELECT fn_add_log_message(log_msgs, 'Get final result done') INTO log_msgs;

  
  SELECT COUNT(*) FROM response___sp_permissions_group_readlist r INTO v_count;
  SELECT JSON_SET(result, '$.recordCount', v_count) INTO result;
  
  SELECT fn_add_log_message(log_msgs, 'Result count done') INTO log_msgs;


  --  
  -- Send the response
  --
  SELECT
    r.group_name,
    r.permission_name
  FROM response___sp_permissions_group_readlist r;


END
$$

DELIMITER ;

# .\Procedures\sp_permissions_group_delete.sql
DELIMITER $$

CREATE PROCEDURE sp_permissions_group_delete(
  IN p_json json,
  OUT result json
)
BEGIN

  --
  -- Variables
  --
  DECLARE procedure_name varchar(100) DEFAULT 'sp_permissions_group_delete';
  DECLARE error_msg varchar(1000) DEFAULT '';
  DECLARE error_log_id int DEFAULT 0;
  DECLARE v_count int DEFAULT 0;
  DECLARE log_msgs json DEFAULT JSON_ARRAY();
  DECLARE within_tran bool DEFAULT FALSE;
  DECLARE tran_started bool DEFAULT TRUE;  

  -- Fields
  DECLARE group_name varchar(1000);
  DECLARE permission_names_json json;

  --
  -- Error handling declarations
  --
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    -- Get error info
    GET CURRENT DIAGNOSTICS CONDITION 1
      @sqlstate = RETURNED_SQLSTATE, 
      @errno = MYSQL_ERRNO,
      @text = MESSAGE_TEXT;
    
    IF tran_started THEN
      ROLLBACK;
    ELSE
       ROLLBACK TO SAVEPOINT sp_permissions_group_delete; 
    END IF;

    CALL sp_handle_error_diagnostic(@sqlstate, @errno, @text, log_msgs, procedure_name, result);

  END;


  --
  -- Temp tables
  --
  DROP TEMPORARY TABLE IF EXISTS response___sp_permissions_group_delete;
  CREATE TEMPORARY TABLE response___sp_permissions_group_delete 
    SELECT
      gr.name AS group_name,
      p.name AS permission_name
    FROM role gr 
    INNER JOIN permission_role pg ON gr.name = pg.group_name
    INNER JOIN permission p ON pg.permission_name = p.name
    LIMIT 0;

  DROP TEMPORARY TABLE IF EXISTS permission_names;
  CREATE TEMPORARY TABLE permission_names
  (
    p_name varchar(100)
  );



  --
  -- Log the parameter values passed
  --
  SELECT fn_add_log_message(log_msgs, 'ParameterList:') INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('p_json: ', IFNULL(p_json, 'NULL'))) INTO log_msgs;	



  --
  -- Default values
  --
  CALL sp_within_transaction(within_tran);
  SET result = JSON_OBJECT('success', TRUE, 'msg', '', 'errorLogId', 0, 'recordCount', 0);  



  --
  -- Start Tran or Savepoint
  --
  IF within_tran THEN
    SAVEPOINT sp_permissions_group_delete;
  ELSE 
    START TRANSACTION;
    SET tran_started = TRUE;
  END IF;   


  --
  -- Validate input value
  --
  IF JSON_VALID(p_json) = 0 THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = 'The json input is not valid.'; 
  END IF;
  

  --
  -- Get json values
  --
  SELECT
    JSON_VALUE(p_json, '$.group'),
    JSON_VALUE(p_json, '$.permission')
  INTO group_name, permission_names_json;


  INSERT INTO permission_names (p_name)
  SELECT permission 
  FROM JSON_TABLE(permission_names_json, '$[*]' COLUMNS(
       permission varchar(100) PATH '$'
      ) 
    ) AS jt;

  SELECT fn_add_log_message(log_msgs, 'Get json values done') INTO log_msgs;



  --
  -- Validate json values
  --
  IF IFNULL(group_name,'')='' THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = 'The group name is required.'; 

  END IF;

  IF NOT EXISTS (
    SELECT 1 
    FROM role gr 
    WHERE gr.name = group_name
  ) 
  THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = 'The group was not found.';
     
  END IF; 

  IF EXISTS (
    SELECT
      1
    FROM permission_names pn
    LEFT JOIN permission p ON p.name = pn.p_name
    WHERE p.name IS NULL 
  ) THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = 'One or more permission(s) was not found.';

  END IF;



  SELECT fn_add_log_message(log_msgs, 'Validate input values done') INTO log_msgs;



  -- 
  -- Then delete role gr
  --
  DELETE pg
    FROM permission_role pg
    INNER JOIN permission_names pn ON pg.permission_name = pn.p_name
    WHERE pg.group_name = group_name;

  SELECT fn_add_log_message(log_msgs, 'Delete record done') INTO log_msgs;



  -- 
  -- Get records for group
  --
  INSERT INTO response___sp_permissions_group_delete (group_name, permission_name)
  SELECT
    pg.group_name,
    pg.permission_name
  FROM permission_role pg
  WHERE pg.group_name = group_name;

  SELECT fn_add_log_message(log_msgs, 'Get return values done') INTO log_msgs;

  
  SELECT COUNT(*) FROM response___sp_permissions_group_delete r INTO v_count;
  SELECT JSON_SET(result, '$.recordCount', v_count) INTO result;


  --  
  -- Send the response
  --
  SELECT
    r.group_name,
    r.permission_name
  FROM response___sp_permissions_group_delete r;



  -- Commit
  IF tran_started THEN
    COMMIT;
  END IF;

END
$$

DELIMITER ;

# .\Procedures\sp_permissions_group_write.sql
DELIMITER $$

CREATE PROCEDURE sp_permissions_group_create(
  IN p_json json,
  OUT result json
)
BEGIN

  --
  -- Variables
  --
  DECLARE procedure_name varchar(100) DEFAULT 'sp_permissions_group_create';
  DECLARE error_msg varchar(1000) DEFAULT '';
  DECLARE error_log_id int DEFAULT 0;
  DECLARE v_count int DEFAULT 0;
  DECLARE log_msgs json DEFAULT JSON_ARRAY();
  DECLARE within_tran bool DEFAULT FALSE;
  DECLARE tran_started bool	DEFAULT	TRUE;  

  -- Fields
  DECLARE group_name varchar(1000);
  DECLARE permission_names_json json;
  


  --
  -- Error handling declarations
  --
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    -- Get error info
    GET CURRENT DIAGNOSTICS CONDITION 1
      @sqlstate = RETURNED_SQLSTATE, 
      @errno = MYSQL_ERRNO,
      @text = MESSAGE_TEXT;

  	IF tran_started	THEN
  		ROLLBACK;
  	ELSE
  		 ROLLBACK TO SAVEPOINT sp_permissions_group_create;	
  	END	IF;
  
  	CALL sp_handle_error_diagnostic(@sqlstate, @errno, @text,	log_msgs,	procedure_name,	result);

  END;


  --
  -- Temp tables
  --
  DROP TEMPORARY TABLE IF EXISTS response___sp_permissions_group_create;
  CREATE TEMPORARY TABLE response___sp_permissions_group_create 
    SELECT 
      gr.name AS group_name, 
      p.name AS permission_name 
    FROM permission p
    INNER JOIN permission_role pg ON p.name = pg.permission_name
    INNER JOIN role gr ON p.name = gr.name
    LIMIT 0;

  DROP TEMPORARY TABLE IF EXISTS permission_names;
  CREATE TEMPORARY TABLE permission_names
  (
    p_name varchar(100)
  );



  --
  -- Log the parameter values passed
  --
  SELECT fn_add_log_message(log_msgs, 'ParameterList:') INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('p_json: ', IFNULL(p_json, 'NULL'))) INTO log_msgs;
	


  --
  -- Default values
  --
  CALL sp_within_transaction(within_tran);
  SET result = JSON_OBJECT('success', TRUE, 'msg', '', 'errorLogId', 0, 'recordCount', 0);
   


  --
  -- Start Tran	or Savepoint
  --
  IF within_tran THEN
	SAVEPOINT sp_permissions_group_create;
  ELSE 
	START TRANSACTION;
	SET	tran_started = TRUE;
  END IF;



  --
  -- Validate json input
  --
  IF JSON_VALID(p_json) = 0 THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = 'The json input is not valid.'; 
  END IF;


  --
  -- Get json values
  --
  SELECT
    JSON_VALUE(p_json, '$.group'),
    JSON_VALUE(p_json, '$.permissions')
  INTO group_name, permission_names_json;


  INSERT INTO permission_names (p_name)
  SELECT permission 
  FROM JSON_TABLE(permission_names_json, '$[*]' COLUMNS(
       permission varchar(100) PATH '$'
      ) 
    ) AS jt;
  
  SELECT fn_add_log_message(log_msgs, 'Get json values done') INTO log_msgs;



  --
  -- Validate json values
  --
  IF IFNULL(group_name,'')='' THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = 'The group name is required.'; 

  END IF;
  
  IF NOT EXISTS (
    SELECT 1 
    FROM role gr 
    WHERE gr.name = group_name
  ) 
  THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = 'The group was not found.';
     
  END IF; 
  
  IF EXISTS (
    SELECT
      1
    FROM permission_names pn
    LEFT JOIN permission p ON p.name = pn.p_name
    WHERE p.name IS NULL 
  ) THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = 'One or more permission(s) was not found.';

  END IF;

  -- Do not stop just...
  -- Remove permissions from permission_names that are assigned to group already
  DELETE pn
  FROM permission_names pn
  WHERE EXISTS(
    SELECT
      1
    FROM permission_role pg
    WHERE pg.group_name = group_name
    AND pg.permission_name = pn.p_name
  );
  

  SELECT fn_add_log_message(log_msgs, 'Validate json values done') INTO log_msgs;


  -- 
  -- Asign permissions to group
  --
  INSERT INTO permission_role (permission_name, group_name)
    SELECT
      pn.p_name,
      group_name
    FROM permission_names pn;

  -- 
  -- Get final result
  --
  INSERT INTO response___sp_permissions_group_create (group_name, permission_name)
  SELECT
    group_name,
    permission_name
  FROM permission_role pg
  WHERE pg.group_name = group_name;

 
  SELECT fn_add_log_message(log_msgs, 'Get final result done') INTO log_msgs;


  
  SELECT COUNT(*) FROM response___sp_permissions_group_create r INTO v_count;
  SELECT JSON_SET(result, '$.recordCount', v_count) INTO result;


  --  
  -- Send the response
  --
  SELECT
    r.group_name,
    r.permission_name
  FROM response___sp_permissions_group_create r;
  

  IF tran_started THEN
    COMMIT;
  END IF;

END
$$

DELIMITER ;

# .\Procedures\sp_permissions_delete.sql
DELIMITER $$

CREATE PROCEDURE sp_permissions_delete(
  IN name varchar(100),
  OUT result json
)
BEGIN

  --
  -- Variables
  --
  DECLARE procedure_name varchar(100) DEFAULT 'sp_permissions_delete';
  DECLARE error_msg varchar(1000) DEFAULT '';
  DECLARE error_log_id int DEFAULT 0;
  DECLARE v_count int DEFAULT 0;
  DECLARE log_msgs json DEFAULT JSON_ARRAY();
  DECLARE within_tran bool DEFAULT FALSE;
  DECLARE tran_started bool DEFAULT TRUE;


  --
  -- Error handling declarations
  --
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    -- Get error info
    GET CURRENT DIAGNOSTICS CONDITION 1
      @sqlstate = RETURNED_SQLSTATE, 
      @errno = MYSQL_ERRNO,
      @text = MESSAGE_TEXT;
    
    IF tran_started THEN
      ROLLBACK;
    ELSE
       ROLLBACK TO SAVEPOINT sp_permissions_delete; 
    END IF;

    CALL sp_handle_error_diagnostic(@sqlstate, @errno, @text, log_msgs, procedure_name, result);

  END;

  --
  -- Temp tables
  --
  DROP TEMPORARY TABLE IF EXISTS response___sp_permissions_delete;
  CREATE TEMPORARY TABLE response___sp_permissions_delete 
    SELECT * FROM permission LIMIT 0;



  --
  -- Log the parameter values passed
  --
  SELECT fn_add_log_message(log_msgs, 'ParameterList:') INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('name: ', IFNULL(name, 'NULL'))) INTO log_msgs;



  --
  -- Default values
  --
  CALL sp_within_transaction(within_tran);
  SET result = JSON_OBJECT('success', TRUE, 'msg', '', 'errorLogId', 0, 'recordCount', 0);
   


  --
  -- Start Tran or Savepoint
  --
  IF within_tran THEN
    SAVEPOINT sp_permissions_delete;
  ELSE 
    START TRANSACTION;
    SET tran_started = TRUE;
  END IF;



  --
  -- Validate input value
  --
  IF IFNULL(name,'')='' THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = '400|The field name is required.';
     
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM permission p WHERE p.name = name
  ) THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = '404|The permission was not found.';
     
  END IF;
  

  SELECT fn_add_log_message(log_msgs, 'Validate input values done') INTO log_msgs;



  -- 
  -- Get record to be deleted
  --
  INSERT INTO response___sp_permissions_delete (name, description)
  SELECT
    name,
    description
  FROM permission p
  WHERE p.name = name;

  SELECT fn_add_log_message(log_msgs, 'Old values save done') INTO log_msgs;



  --
  -- Delete permission association to groups first
  --
  DELETE
    FROM permission_role pg
  WHERE pg.permission_name = name;


  -- 
  -- Then delete permission
  --
  DELETE
    FROM permission p
    WHERE p.name = name;

  SELECT fn_add_log_message(log_msgs, 'Delete record done') INTO log_msgs;


  
  SELECT COUNT(*) FROM response___sp_permissions_delete r INTO v_count;
  SELECT JSON_SET(result, '$.recordCount', v_count) INTO result;


  --  
  -- Send the response
  --
  SELECT
    r.name,
    r.description
  FROM response___sp_permissions_delete r;



  -- Commit
  IF tran_started THEN
    COMMIT;
  END IF;

END
$$

DELIMITER ;

# .\Procedures\sp_permissions_create.sql
DELIMITER $$

CREATE PROCEDURE sp_permissions_create(
  IN p_json json,
  OUT result json
)
BEGIN

  --
  -- Variables
  --
  DECLARE procedure_name varchar(100) DEFAULT 'sp_permissions_create';
  DECLARE error_msg varchar(1000) DEFAULT '';
  DECLARE error_log_id int DEFAULT 0;
  DECLARE v_count int DEFAULT 0;
  DECLARE log_msgs json DEFAULT JSON_ARRAY();
	DECLARE	within_tran	bool DEFAULT FALSE;
	DECLARE	tran_started bool	DEFAULT	TRUE;

  -- Fields
  DECLARE name varchar(100);
  DECLARE description varchar(1000);
  


  --
  -- Error handling declarations
  --
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    -- Get error info
    GET CURRENT DIAGNOSTICS CONDITION 1
      @sqlstate = RETURNED_SQLSTATE, 
      @errno = MYSQL_ERRNO,
      @text = MESSAGE_TEXT;

		IF tran_started	THEN
			ROLLBACK;
		ELSE
			 ROLLBACK	TO SAVEPOINT sp_permissions_create;	
		END	IF;

		CALL sp_handle_error_diagnostic(@sqlstate, @errno, @text,	log_msgs,	procedure_name,	result);

  END;
   
  --
  -- Temp tables
  --
  DROP TEMPORARY TABLE IF EXISTS response___sp_permissions_create;
  CREATE TEMPORARY TABLE response___sp_permissions_create 
    SELECT * FROM permission p LIMIT 0;



  --
  -- Log the parameter values passed
  --
  SELECT fn_add_log_message(log_msgs, 'ParameterList:') INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('p_json: ', IFNULL(p_json, 'NULL'))) INTO log_msgs;



  --
  -- Default values
  --
  CALL sp_within_transaction(within_tran);
  SET result = JSON_OBJECT('success', TRUE, 'msg', '', 'errorLogId', 0, 'recordCount', 0);
   


	--
	-- Start Tran	or Savepoint
	--
	IF within_tran THEN
		SAVEPOINT	sp_permissions_create;
	ELSE 
		START	TRANSACTION;
		SET	tran_started = TRUE;
	END	IF;


  --
  -- Validate json input
  --
  IF JSON_VALID(p_json) = 0 THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = '400|The json input is not valid.';
     
  END IF;



  --
  -- Get json values
  --
  SELECT
    JSON_VALUE (p_json, '$.name'),
    JSON_VALUE (p_json, '$.description') 
  INTO name, 
      description;
  
  SELECT fn_add_log_message(log_msgs, 'Get json values done') INTO log_msgs;



  --
  -- Validate json values
  --
  IF IFNULL(name,'')='' THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = '400|The field name is required.';
     
  END IF;

  IF EXISTS (
    SELECT 1 
    FROM permission p 
    WHERE p.name = name
  ) 
  THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = '400|The permission name already exist.';
     
  END IF;
  
  SELECT fn_add_log_message(log_msgs, 'Validate json values done') INTO log_msgs;



  -- 
  -- Create permission
  --
  INSERT INTO permission
    SET name = name,
        description = description;



  -- 
  -- Get final result
  --
  INSERT INTO response___sp_permissions_create (name, description)
  SELECT
    name,
    description
  FROM permission p
  WHERE p.name = name;

  SELECT fn_add_log_message(log_msgs, 'Get final result done') INTO log_msgs;


  
  SELECT COUNT(*) FROM response___sp_permissions_create r INTO v_count;
  SELECT JSON_SET(result, '$.recordCount', v_count) INTO result;



  --  
  -- Send the response
  --
  SELECT
    r.name,
    r.description
  FROM response___sp_permissions_create r;



	-- Commit
	IF tran_started	THEN
		COMMIT;
	END	IF;	
 
END
$$

DELIMITER ;

# .\Procedures\sp_groups_update.sql
DELIMITER $$

CREATE PROCEDURE sp_groups_update(
  IN p_name varchar(100),
  IN p_json json,
  OUT result json
)
BEGIN

  --
  -- Variables
  --
  DECLARE procedure_name varchar(100) DEFAULT 'sp_groups_update';
  DECLARE error_msg varchar(1000) DEFAULT '';
  DECLARE error_log_id int DEFAULT 0;
  DECLARE v_count int DEFAULT 0;
  DECLARE log_msgs json DEFAULT JSON_ARRAY();
	DECLARE	within_tran	bool DEFAULT FALSE;
	DECLARE	tran_started bool	DEFAULT	TRUE;

  -- Fields
  DECLARE v_name varchar(100);
  DECLARE v_description varchar(1000);
  


  --
  -- Error handling declarations
  --
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    -- Get error info
    GET CURRENT DIAGNOSTICS CONDITION 1
      @sqlstate = RETURNED_SQLSTATE, 
      @errno = MYSQL_ERRNO,
      @text = MESSAGE_TEXT;

		IF tran_started	THEN
			ROLLBACK;
		ELSE
			 ROLLBACK	TO SAVEPOINT sp_groups_update;	
		END	IF;

		CALL sp_handle_error_diagnostic(@sqlstate, @errno, @text,	log_msgs,	procedure_name,	result);

  END;
   
  --
  -- Temp tables
  --
  DROP TEMPORARY TABLE IF EXISTS response___sp_groups_update;
  CREATE TEMPORARY TABLE response___sp_groups_update 
    SELECT * FROM role gr LIMIT 0;



  --
  -- Log the parameter values passed
  --
  SELECT fn_add_log_message(log_msgs, 'ParameterList:') INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('p_name: ', IFNULL(p_name, 'NULL'))) INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('p_json: ', IFNULL(p_json, 'NULL'))) INTO log_msgs;




  --
  -- Default values
  --
  CALL sp_within_transaction(within_tran);
  SET result = JSON_OBJECT('success', TRUE, 'msg', '', 'errorLogId', 0, 'recordCount', 0);
   


	--
	-- Start Tran	or Savepoint
	--
	IF within_tran THEN
		SAVEPOINT	sp_groups_update;
	ELSE 
		START	TRANSACTION;
		SET	tran_started = TRUE;
	END	IF;


  --
  -- Validate input
  --
  IF IFNULL(p_name,'') = '' THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = '400|The old group name is required.';
     
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM role gr WHERE gr.name = p_name
  ) THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = '404|The group to be updated was not found.';
     
  END IF;
  IF JSON_VALID(p_json) = 0 THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = '400|The json input is not valid.';
     
  END IF;



  --
  -- Get json values
  --
  SELECT
    JSON_VALUE (p_json, '$.name'),
    JSON_VALUE (p_json, '$.description') 
  INTO v_name, 
      v_description;
  
  SELECT fn_add_log_message(log_msgs, 'Get json values done') INTO log_msgs;



  --
  -- Validate json values
  --
  IF IFNULL(v_name,'')='' THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = '400|The new field name is required.';
     
  END IF;

  IF EXISTS (
    SELECT 1 
    FROM role gr
    WHERE gr.name = v_name
    AND gr.name != p_name
  ) 
  THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = '400|The group name already exist.';
     
  END IF;
  
  SELECT fn_add_log_message(log_msgs, 'Validate json values done') INTO log_msgs;



  -- 
  -- Update group
  -- 
  UPDATE role gr
    SET gr.name = v_name,
        gr.description = v_description
  WHERE gr.name = p_name;



  -- 
  -- Get final result
  --
  INSERT INTO response___sp_groups_update (name, description)
  SELECT
    name,
    description
  FROM role gr
  WHERE gr.name = v_name;

  SELECT fn_add_log_message(log_msgs, 'Get final result done') INTO log_msgs;


  
  SELECT COUNT(*) FROM response___sp_groups_update r INTO v_count;
  SELECT JSON_SET(result, '$.recordCount', v_count) INTO result;



  --  
  -- Send the response
  --
  SELECT
    r.name,
    r.description
  FROM response___sp_groups_update r;



	-- Commit
	IF tran_started	THEN
		COMMIT;
	END	IF;
 
END
$$

DELIMITER ;

# .\Procedures\sp_groups_readlist.sql
DELIMITER $$

CREATE PROCEDURE sp_groups_readlist(
  IN offsetRows int,
  IN fetchRows int,
  IN filterJson json,
  IN searchJson json,
  OUT result json
)
BEGIN

  --
  -- Variables
  --
  DECLARE procedure_name varchar(100) DEFAULT 'sp_groups_readlist';
  DECLARE error_msg varchar(1000) DEFAULT '';
  DECLARE error_log_id int DEFAULT 0;
  DECLARE v_count int DEFAULT 0;
  DECLARE log_msgs json DEFAULT JSON_ARRAY();

  -- filters
  DECLARE name_filter varchar(100);
  DECLARE description_filter varchar(1000);

  -- searchs
  DECLARE name_search varchar(100);
  DECLARE description_search varchar(1200);


  --
  -- Error handling declarations
  --
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    -- Get error info
    GET CURRENT DIAGNOSTICS CONDITION 1
      @sqlstate = RETURNED_SQLSTATE, 
      @errno = MYSQL_ERRNO,
      @text = MESSAGE_TEXT;

    CALL sp_handle_error_diagnostic(@sqlstate, @errno, @text, log_msgs, procedure_name, result);

  END;

  --
  -- Temp tables
  --
  DROP TEMPORARY TABLE IF EXISTS response___sp_permissions_readlist;
  CREATE TEMPORARY TABLE response___sp_permissions_readlist 
    SELECT * FROM role gr LIMIT 0;



  --
  -- Log the parameter values passed
  --
	SELECT fn_add_log_message(log_msgs, 'ParameterList:') INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('offsetRows: ', IFNULL(CAST(offsetRows AS CHAR), 'NULL'))) INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('fetchRows: ', IFNULL(CAST(fetchRows AS char(20)), 'NULL'))) INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('filterJson: ', IFNULL(filterJson, 'NULL'))) INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('searchJson: ', IFNULL(CAST(searchJson AS char), 'NULL'))) INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('ProfileId: ', IFNULL(CAST(0 AS char), 'NULL'))) INTO log_msgs;



  --
  -- Default values
  --
  SET offsetRows = IFNULL(offsetRows, 0);
  SET fetchRows = IFNULL(fetchRows, 10);
  SET result = JSON_OBJECT('success', TRUE, 'msg', '', 'errorLogId', 0, 'recordCount', 0);
  
  IF fetchRows = 0 THEN
  SELECT
    COUNT(1) INTO fetchRows
  FROM role gr;
  END IF;  
  IF JSON_VALID(filterJson) = 0 THEN
    SET filterJson = '{}';
  END IF;
  IF JSON_VALID(searchJson) = 0 THEN
    SET searchJson = '{}';
  END IF;

  SELECT fn_add_log_message(log_msgs, 'Default values done') INTO log_msgs;



  --
  -- Get filter values
  --
  SELECT JSON_VALUE (filterJson, '$.name') INTO name_filter;
  SELECT JSON_VALUE (filterJson, '$.description') INTO description_filter;
  
  SELECT fn_add_log_message(log_msgs, 'Get filter values done') INTO log_msgs;


  --
  -- Get search values
  --
  SELECT JSON_VALUE (searchJson, '$.name') INTO name_search;
  SELECT JSON_VALUE (searchJson, '$.description') INTO description_search;
  
  SELECT fn_add_log_message(log_msgs, 'Get search values done') INTO log_msgs;



  -- 
  -- Get final result
  --
  INSERT INTO response___sp_permissions_readlist (name, description)
  SELECT
    name,
    description
  FROM role gr
  
  -- filter
  WHERE (name_filter IS NULL OR name_filter = name)
  AND (description_filter IS NULL OR description_filter = gr.description)

  -- search
  AND (name_search IS NULL OR gr.name LIKE name_search)
  AND (description_search IS NULL OR gr.description LIKE description_search);
 
  SELECT fn_add_log_message(log_msgs, 'Get final result done') INTO log_msgs;

  
  SELECT COUNT(*) FROM response___sp_permissions_readlist r INTO v_count;
  SELECT JSON_SET(result, '$.recordCount', v_count) INTO result;

  SELECT fn_add_log_message(log_msgs, 'Result count done') INTO log_msgs;


  --  
  -- Send the response
  --
  SELECT
    r.name,
    r.description
  FROM response___sp_permissions_readlist r;


END
$$

DELIMITER ;

# .\Procedures\sp_groups_read.sql
DELIMITER $$

CREATE PROCEDURE sp_groups_read(
  IN group_name varchar(100),
  OUT result json
)
BEGIN

  --
  -- Variables
  --
  DECLARE procedure_name varchar(100) DEFAULT 'sp_groups_read';
  DECLARE error_msg varchar(1000) DEFAULT '';
  DECLARE error_log_id int DEFAULT 0;
  DECLARE v_count int DEFAULT 0;
  DECLARE log_msgs json DEFAULT JSON_ARRAY();



  --
  -- Error handling declarations
  --
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    -- Get error info
    GET CURRENT DIAGNOSTICS CONDITION 1
      @sqlstate = RETURNED_SQLSTATE, 
      @errno = MYSQL_ERRNO,
      @text = MESSAGE_TEXT;

    CALL sp_handle_error_diagnostic(@sqlstate, @errno, @text, log_msgs, procedure_name, result);

  END;



  --
  -- Temp tables
  --
  DROP TEMPORARY TABLE IF EXISTS response___sp_groups_read;
  CREATE TEMPORARY TABLE response___sp_groups_read 
    SELECT * FROM role gr LIMIT 0;



  --
  -- Log the parameter values passed
  --
  SELECT fn_add_log_message(log_msgs, 'ParameterList:') INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('group_name: ', IFNULL(CAST(group_name AS CHAR), 'NULL'))) INTO log_msgs;



  --
  -- Default values
  --
  SET result = JSON_OBJECT('success', TRUE, 'msg', '', 'errorLogId', 0, 'recordCount', 0);



  --
  -- Validate input value
  --
  IF IFNULL(group_name,'')='' THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = 'The field group_name is required.'; 

  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM role gr WHERE gr.name = group_name
  ) THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = 'The role gr was not found.';
          
  END IF;
  
  SELECT fn_add_log_message(log_msgs, 'Validate input values done') INTO log_msgs;
  


  -- 
  -- Get final result
  --
  INSERT INTO response___sp_groups_read (name, description)
  SELECT
    gr.name,
    gr.description
  FROM role gr
  WHERE gr.name = group_name;
 
  SELECT fn_add_log_message(log_msgs, 'Get final result done') INTO log_msgs;

  
  SELECT COUNT(*) FROM response___sp_groups_read r INTO v_count;
  SELECT JSON_SET(result, '$.recordCount', v_count) INTO result;

  SELECT fn_add_log_message(log_msgs, 'Record count done') INTO log_msgs;


  --  
  -- Send the response
  --
  SELECT
    r.name,
    r.description
  FROM response___sp_groups_read r;


END
$$

DELIMITER ;

# .\Procedures\sp_groups_delete.sql
DELIMITER $$

CREATE PROCEDURE sp_groups_delete(
  IN name varchar(100),
  OUT result json
)
BEGIN

  --
  -- Variables
  --
  DECLARE procedure_name varchar(100) DEFAULT 'sp_groups_delete';
  DECLARE error_msg varchar(1000) DEFAULT '';
  DECLARE error_log_id int DEFAULT 0;
  DECLARE v_count int DEFAULT 0;
  DECLARE log_msgs json DEFAULT JSON_ARRAY();
  DECLARE within_tran bool DEFAULT FALSE;
  DECLARE tran_started bool DEFAULT TRUE;


  --
  -- Error handling declarations
  --
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    -- Get error info
    GET CURRENT DIAGNOSTICS CONDITION 1
      @sqlstate = RETURNED_SQLSTATE, 
      @errno = MYSQL_ERRNO,
      @text = MESSAGE_TEXT;
    
    IF tran_started THEN
      ROLLBACK;
    ELSE
       ROLLBACK TO SAVEPOINT sp_groups_delete; 
    END IF;

    CALL sp_handle_error_diagnostic(@sqlstate, @errno, @text, log_msgs, procedure_name, result);

  END;

  --
  -- Temp tables
  --
  DROP TEMPORARY TABLE IF EXISTS response___sp_groups_delete;
  CREATE TEMPORARY TABLE response___sp_groups_delete 
    SELECT * FROM role gr LIMIT 0;



  --
  -- Log the parameter values passed
  --
  SELECT fn_add_log_message(log_msgs, 'ParameterList:') INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('name: ', IFNULL(name, 'NULL'))) INTO log_msgs;



  --
  -- Default values
  --
  CALL sp_within_transaction(within_tran);
  SET result = JSON_OBJECT('success', TRUE, 'msg', '', 'errorLogId', 0, 'recordCount', 0);
   


  --
  -- Start Tran or Savepoint
  --
  IF within_tran THEN
    SAVEPOINT sp_groups_delete;
  ELSE 
    START TRANSACTION;
    SET tran_started = TRUE;
  END IF;



  --
  -- Validate input value
  --
  IF IFNULL(name,'')='' THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = 'The field name is required.';
     
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM role gr WHERE gr.name = name
  ) THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = 'The group was not found.';
     
  END IF;
  

  SELECT fn_add_log_message(log_msgs, 'Validate input values done') INTO log_msgs;



  -- 
  -- Get record to be deleted
  --
  INSERT INTO response___sp_groups_delete (name, description)
  SELECT
    name,
    description
  FROM role gr
  WHERE gr.name = name;

  SELECT fn_add_log_message(log_msgs, 'Save old values done') INTO log_msgs;



  --
  -- Delete permission associations to this group first
  --
  DELETE
    FROM permission_role pg
  WHERE pg.group_name = name;


  -- 
  -- Then delete group
  --
  DELETE
    FROM role gr
    WHERE gr.name = name;

  SELECT fn_add_log_message(log_msgs, 'Delete record done') INTO log_msgs;


  
  SELECT COUNT(*) FROM response___sp_groups_delete r INTO v_count;
  SELECT JSON_SET(result, '$.recordCount', v_count) INTO result;


  --  
  -- Send the response
  --
  SELECT
    r.name,
    r.description
  FROM response___sp_groups_delete r;



  -- Commit
  IF tran_started THEN
    COMMIT;
  END IF;

END
$$

DELIMITER ;

# .\Procedures\sp_groups_create.sql
DELIMITER $$

CREATE PROCEDURE sp_groups_create(
  IN p_json json,
  OUT result json
)
BEGIN

  --
  -- Variables
  --
  DECLARE procedure_name varchar(100) DEFAULT 'sp_groups_create';
  DECLARE error_msg varchar(1000) DEFAULT '';
  DECLARE error_log_id int DEFAULT 0;
  DECLARE v_count int DEFAULT 0;
  DECLARE log_msgs json DEFAULT JSON_ARRAY();
	DECLARE	within_tran	bool DEFAULT FALSE;
	DECLARE	tran_started bool	DEFAULT	TRUE;

  -- Fields
  DECLARE name varchar(100);
  DECLARE description varchar(1000);
  


  --
  -- Error handling declarations
  --
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    -- Get error info
    GET CURRENT DIAGNOSTICS CONDITION 1
      @sqlstate = RETURNED_SQLSTATE, 
      @errno = MYSQL_ERRNO,
      @text = MESSAGE_TEXT;

		IF tran_started	THEN
			ROLLBACK;
		ELSE
			 ROLLBACK	TO SAVEPOINT sp_groups_create;	
		END	IF;

		CALL sp_handle_error_diagnostic(@sqlstate, @errno, @text,	log_msgs,	procedure_name,	result);

  END;
   
  --
  -- Temp tables
  --
  DROP TEMPORARY TABLE IF EXISTS response___sp_groups_write;
  CREATE TEMPORARY TABLE response___sp_groups_write 
    SELECT * FROM groups_roles gr LIMIT 0;



  --
  -- Log the parameter values passed
  --
  SELECT fn_add_log_message(log_msgs, 'ParameterList:') INTO log_msgs;
  SELECT fn_add_log_message(log_msgs, CONCAT('p_json: ', IFNULL(p_json, 'NULL'))) INTO log_msgs;



  --
  -- Default values
  --
  CALL sp_within_transaction(within_tran);
  SET result = JSON_OBJECT('success', TRUE, 'msg', '', 'errorLogId', 0, 'recordCount', 0);
   


	--
	-- Start Tran	or Savepoint
	--
	IF within_tran THEN
		SAVEPOINT	sp_groups_create;
	ELSE 
		START	TRANSACTION;
		SET	tran_started = TRUE;
	END	IF;


  --
  -- Validate json input
  --
  IF JSON_VALID(p_json) = 0 THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = 'The json input is not valid.';
     
  END IF;



  --
  -- Get json values
  --
  SELECT
    JSON_VALUE (p_json, '$.name'),
    JSON_VALUE (p_json, '$.description') 
  INTO name, 
      description;
  
  SELECT fn_add_log_message(log_msgs, 'Get json values done') INTO log_msgs;



  --
  -- Validate json values
  --
  IF IFNULL(name,'')='' THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = 'The field name is required.';
     
  END IF;

  IF EXISTS (
    SELECT 1 
    FROM role r 
    WHERE r.name = name
  ) 
  THEN
    SIGNAL SQLSTATE '12345'
      SET MESSAGE_TEXT = 'The group name already exist.';
     
  END IF;
  
  SELECT fn_add_log_message(log_msgs, 'Validate json values done') INTO log_msgs;



  -- 
  -- Create group
  --
  INSERT INTO role
    SET name = name,
        description = description;



  -- 
  -- Get final result
  --
  INSERT INTO response___sp_groups_write (name, description)
  SELECT
    name,
    description
  FROM role r
  WHERE r.name = name;

  SELECT fn_add_log_message(log_msgs, 'Get final result done') INTO log_msgs;


  
  SELECT COUNT(*) FROM response___sp_groups_write r INTO v_count;
  SELECT JSON_SET(result, '$.recordCount', v_count) INTO result;



  --  
  -- Send the response
  --
  SELECT
    r.name,
    r.description
  FROM response___sp_groups_write r;



	-- Commit
	IF tran_started	THEN
		COMMIT;
	END	IF;	
 
END
$$

DELIMITER ;

# .\Tables\flyway_schema_history.Tables.sql
CREATE TABLE flyway_schema_history (
  installed_rank INT NOT NULL,
  version VARCHAR(50) DEFAULT NULL,
  description VARCHAR(200) NOT NULL,
  type VARCHAR(20) NOT NULL,
  script VARCHAR(1000) NOT NULL,
  checksum INT DEFAULT NULL,
  installed_by VARCHAR(100) NOT NULL,
  installed_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  execution_time INT NOT NULL,
  success TINYINT(1) NOT NULL,
  PRIMARY KEY (installed_rank)
)
ENGINE = INNODB,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_0900_ai_ci;

ALTER TABLE flyway_schema_history 
  ADD INDEX flyway_schema_history_s_idx(success);


# .\PostDeployment.sql

/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;